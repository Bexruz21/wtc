<!doctype html>
<html>

<head>
  <meta charset="utf-8" />
  <title>Simple WebRTC via ngrok (signaling)</title>
  <style>
    body {
      font-family: Inter, system-ui, sans-serif;
      padding: 18px;
      max-width: 900px;
      margin: 0 auto;
    }

    .row {
      display: flex;
      gap: 12px;
      align-items: center;
      margin-bottom: 8px;
    }

    video {
      width: 48%;
      border-radius: 6px;
      border: 1px solid #222;
      background: #000;
    }

    #controls {
      margin-top: 12px;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    input[type=text] {
      width: 420px;
      padding: 8px;
    }

    textarea {
      width: 100%;
      height: 80px;
      margin-top: 8px;
      font-family: monospace;
    }

    button {
      padding: 8px 12px;
      cursor: pointer;
    }

    .log {
      margin-top: 8px;
      height: 120px;
      overflow: auto;
      background: #111;
      color: #0f0;
      padding: 8px;
      font-family: monospace;
      font-size: 12px;
    }

    .hint {
      color: #666;
      font-size: 13px;
      margin-bottom: 8px;
    }
  </style>
</head>

<body>
  <div class="row">
    <label>WebSocket:</label>
    <span>wss://abc123.ngrok-free.app</span>
  </div>

  <div class="row">
    <button id="startBtn" disabled>Start (getUserMedia)</button>
    <button id="callBtn" disabled>Call (createOffer)</button>
    <button id="hangBtn" disabled>Hangup</button>
  </div>

  <div style="display:flex; gap:12px; margin-top:12px;">
    <video id="localVideo" autoplay playsinline muted></video>
    <video id="remoteVideo" autoplay playsinline></video>
  </div>

  <div id="controls">
    <div style="flex:1">
      <div class="hint">Логи сигнального канала (и важные сообщения)</div>
      <div id="log" class="log"></div>
    </div>
  </div>

  <script>
    let ws = null;
    let pc = null;
    let localStream = null;

    const logEl = document.getElementById('log');
    const startBtn = document.getElementById('startBtn');
    const callBtn = document.getElementById('callBtn');
    const hangBtn = document.getElementById('hangBtn');

    const WS_URL = "wss://bc19a7e1703c.ngrok-free.app ";

    function log(...args) {
      console.log(...args);
      logEl.innerText += args.map(a => typeof a === 'string' ? a : JSON.stringify(a)).join(' ') + "\n";
      logEl.scrollTop = logEl.scrollHeight;
    }

    function connectWs() {
      try {
        ws = new WebSocket(WS_URL);
      } catch (e) {
        alert('Ошибка WebSocket: ' + e.message);
        return;
      }
      ws.onopen = () => {
        log('WS connected to', WS_URL);
        startBtn.disabled = false;
      };
      ws.onmessage = async (ev) => {
        try {
          const msg = JSON.parse(ev.data);
          log('<<', msg.type || typeof msg);
          if (msg.type === 'offer') {
            await ensurePc();
            await pc.setRemoteDescription(msg);
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            ws.send(JSON.stringify(pc.localDescription));
            log('>> sent answer');
          } else if (msg.type === 'answer') {
            await pc?.setRemoteDescription(msg);
            log('Applied remote answer');
          } else if (msg.type === 'candidate') {
            await pc?.addIceCandidate(msg.candidate);
            log('Added remote candidate');
          }
        } catch (e) {
          log('parse message error', e);
        }
      };
      ws.onclose = () => { log('WS closed'); startBtn.disabled = true; callBtn.disabled = true; hangBtn.disabled = true; };
      ws.onerror = (e) => { log('WS error', e); };
    }

    async function ensurePc() {
      if (pc) return;
      pc = new RTCPeerConnection({
        iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
      });

      pc.onicecandidate = e => {
        if (e.candidate && ws?.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: 'candidate', candidate: e.candidate }));
        }
      };

      pc.ontrack = e => {
        log('ontrack — got remote stream');
        document.getElementById('remoteVideo').srcObject = e.streams[0];
      };

      pc.onconnectionstatechange = () => {
        log('PC state:', pc.connectionState, 'signalingState:', pc.signalingState);
        if (pc.connectionState === 'connected') {
          hangBtn.disabled = false;
        }
      };

      if (localStream) {
        localStream.getTracks().forEach(t => pc.addTrack(t, localStream));
      }
    }

    startBtn.onclick = async () => {
      try {
        localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        document.getElementById('localVideo').srcObject = localStream;
        log('Local media captured');
        await ensurePc();
        callBtn.disabled = false;
      } catch (e) {
        log('getUserMedia error:', e);
        alert('Ошибка доступа к камере/микрофону: ' + (e.message || e));
      }
    };

    callBtn.onclick = async () => {
      if (!ws || ws.readyState !== WebSocket.OPEN) { alert('WS не подключён'); return; }
      await ensurePc();
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      ws.send(JSON.stringify(pc.localDescription));
      log('>> sent offer');
    };

    hangBtn.onclick = () => {
      if (pc) {
        pc.getSenders().forEach(s => { s.track?.stop(); });
        pc.close();
        pc = null;
      }
      if (localStream) {
        localStream.getTracks().forEach(t => t.stop());
        localStream = null;
      }
      document.getElementById('localVideo').srcObject = null;
      document.getElementById('remoteVideo').srcObject = null;
      callBtn.disabled = true;
      hangBtn.disabled = true;
      startBtn.disabled = false;
      log('Call ended / resources released');
    };

    // Автоподключение сразу при загрузке
    window.addEventListener('load', () => {
      connectWs();
    });
  </script>
</body>


</html>